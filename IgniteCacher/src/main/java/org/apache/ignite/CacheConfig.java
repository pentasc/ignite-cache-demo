/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ignite;

import org.apache.ignite.cache.*;
import org.apache.ignite.cache.store.*;
import org.apache.ignite.configuration.*;
import org.apache.ignite.lang.*;

import javax.cache.configuration.*;
import java.sql.*;
import java.util.*;
import org.apache.ignite.cache.store.jdbc.CacheJdbcPojoStore;

/**
 * CacheConfig definition.
 *
 * Code generated by Apache Ignite Schema Import utility: 11/23/2015.
 */
public class CacheConfig {
    /**
    * Configure cache.
    *
    * @param name Cache name.
    * @param storeFactory Cache store factory.
    */
    public static <K, V> CacheConfiguration<K, V> cache(String name, Factory<CacheStore<K, V>> storeFactory) {
        if (storeFactory == null)
             throw new IllegalArgumentException("Cache store factory cannot be null.");

        CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(name);

        ccfg.setCacheStoreFactory(storeFactory);
        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        // Configure cache types. 
        Collection<CacheTypeMetadata> meta = new ArrayList<>();

        // students.
        CacheTypeMetadata type = new CacheTypeMetadata();

        meta.add(type);

        type.setDatabaseSchema("caching");
        type.setDatabaseTable("students");
        type.setKeyType(StudentsKey.class.getName());
        type.setValueType(Students.class.getName());

        // Key fields for students.
        Collection<CacheTypeFieldMetadata> keys = new ArrayList<>();
        keys.add(new CacheTypeFieldMetadata("StudentId", Types.INTEGER, "studentid", Integer.class));
        type.setKeyFields(keys);

        // Value fields for students.
        Collection<CacheTypeFieldMetadata> vals = new ArrayList<>();
        vals.add(new CacheTypeFieldMetadata("StudentId", Types.INTEGER, "studentid", Integer.class));
        vals.add(new CacheTypeFieldMetadata("LastName", Types.VARCHAR, "lastname", String.class));
        vals.add(new CacheTypeFieldMetadata("FirstName", Types.VARCHAR, "firstname", String.class));
        vals.add(new CacheTypeFieldMetadata("Gpa", Types.REAL, "gpa", Float.class));
        vals.add(new CacheTypeFieldMetadata("ScheduleId", Types.INTEGER, "scheduleid", Integer.class));
        type.setValueFields(vals);

        // Query fields for students.
        Map<String, Class<?>> qryFlds = new LinkedHashMap<>();

        qryFlds.put("studentid", Integer.class);
        qryFlds.put("lastname", String.class);
        qryFlds.put("firstname", String.class);
        qryFlds.put("gpa", Float.class);
        qryFlds.put("scheduleid", Integer.class);

        type.setQueryFields(qryFlds);

        // Groups for students.
        Map<String, LinkedHashMap<String, IgniteBiTuple<Class<?>, Boolean>>> grps = new LinkedHashMap<>();

        LinkedHashMap<String, IgniteBiTuple<Class<?>, Boolean>> grpItems = new LinkedHashMap<>();

        grpItems.put("lastname", new IgniteBiTuple<Class<?>, Boolean>(String.class, false));
        grpItems.put("firstname", new IgniteBiTuple<Class<?>, Boolean>(String.class, false));

        grps.put("idx_students_LastName_FirstName", grpItems);

        type.setGroups(grps);

        ccfg.setTypeMetadata(meta);

        return ccfg;
    }
}
